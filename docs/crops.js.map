{"version":3,"file":"crops.js","mappings":"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","sources":["webpack:///./src/crops.tsx","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"sourcesContent":["\"use strict\";\r\n\r\n// should i pull this from a JSON like i'm doing now? or should i just\r\n// hard-code it inline (might be more readable)\r\nimport CROP_DEFINITIONS from \"./crops.json\";\r\n\r\n/* ======== CALCULATION ======== */\r\n\r\ntype CropDefinition = typeof CROP_DEFINITIONS[number];\r\n\r\nenum Season {\r\n    SPRING, SUMMER, FALL, WINTER\r\n}\r\n\r\nnamespace Season {\r\n    export function fromString(s: string): Season {\r\n        switch (s.toUpperCase()) {\r\n            case \"SPRING\":\r\n                return Season.SPRING;\r\n            case \"SUMMER\":\r\n                return Season.SUMMER;\r\n            case \"FALL\":\r\n                return Season.FALL;\r\n            case \"WINTER\":\r\n                return Season.WINTER;\r\n            default:\r\n                throw new Error(`Unknown season ${s}`);\r\n        }\r\n    }\r\n}\r\n\r\ntype CropData = {\r\n    definition: CropDefinition,\r\n    useful_days: number,\r\n    num_harvests: number,\r\n    num_crops: number,\r\n    profit: number,\r\n    daily_profit: number,\r\n};\r\n\r\ntype QualityProbabilities = {\r\n    normal: number,\r\n    silver: number,\r\n    gold: number,\r\n    iridium: number,\r\n};\r\ntype QualityTypes = keyof QualityProbabilities;\r\n\r\nconst SILVER_MULTIPLIER = 1.25;\r\nconst GOLD_MULTIPLIER = 1.5;\r\nconst IRIDIUM_MULTIPLIER = 2.0;\r\n\r\nfunction computeQuality(farming_level: number): QualityProbabilities {\r\n    // https://stardewvalleywiki.com/Farming#Complete_Formula_2\r\n    const fertilizer_level = 0;\r\n\r\n    // Quality for a crop is determined by a series of weighted coin flips.\r\n    // The probabilities for the coins are computed here.\r\n    const p_gold_coin = 0.2 * (farming_level / 10.0) + 0.2 * fertilizer_level * ((farming_level + 2.0) / 12.0) + 0.01;\r\n    const p_silver_coin = Math.min(2 * p_gold_coin, 0.75);\r\n    let p_iridium_coin = p_gold_coin / 2;\r\n\r\n    // TODO: this is only enabled at certain fertilizer levels\r\n    p_iridium_coin = 0;\r\n\r\n    // However, these coins are flipped one at a time, so we have slightly more\r\n    // work to do to find out the final probabilities.\r\n\r\n    // Chance of iridium is just the local chance of iridium.\r\n    const iridium = p_iridium_coin;\r\n    // To get gold, don't be iridium, and pass the gold coin flip.\r\n    const gold = (1 - iridium) * p_gold_coin;\r\n    // Similarly, for silver, don't be iridum or gold, and pass the\r\n    // silver coin flip.\r\n    const silver = (1 - iridium - gold) * p_silver_coin;\r\n    // Base quality is everything else.\r\n    const normal = 1 - iridium - gold - silver;\r\n\r\n    return { normal, silver, gold, iridium };\r\n}\r\n\r\ntype Settings = {\r\n    season: Season,\r\n    start_day: number,\r\n    multiseason_enabled: boolean,\r\n    quality_probabilities: QualityProbabilities | null,\r\n    tiller_enabled: boolean,\r\n};\r\n\r\nfunction calculate(crop: CropDefinition, settings: Settings): CropData | \"out-of-season\" {\r\n    // When is this crop in-season?\r\n    const seasons: Season[] = [];\r\n    const num_seasons = crop.multiseason ?? 1;\r\n    for (let i = 0; i < num_seasons; i++) {\r\n        seasons.push(Season.fromString(crop.season).valueOf() + i);\r\n    }\r\n\r\n    // Bail out if we're out of season\r\n    if (!seasons.includes(settings.season)) {\r\n        return \"out-of-season\";\r\n    }\r\n\r\n    // How many days do we have left?\r\n    const seasons_left = settings.multiseason_enabled\r\n        ? seasons.length - seasons.indexOf(settings.season)\r\n        : 1;\r\n    const days_left = 28 * seasons_left - settings.start_day;\r\n\r\n    // In the number of days remaining, how many harvests do we get?\r\n    let num_harvests = 0;\r\n    let useful_days = 0;\r\n    if (days_left >= crop.days_to_grow) {\r\n        num_harvests += 1;\r\n        useful_days += crop.days_to_grow;\r\n        if (crop.regrowth_period) {\r\n            const extra_harvests = Math.floor((days_left - crop.days_to_grow) / crop.regrowth_period);\r\n            num_harvests += extra_harvests;\r\n            useful_days += extra_harvests * crop.regrowth_period;\r\n        }\r\n    }\r\n\r\n    // How much is a crop worth, on average?\r\n    const base_price = crop.sell_price;\r\n    let quality_price;\r\n    if (settings.quality_probabilities) {\r\n        const q = settings.quality_probabilities;\r\n        // zip together prices and probabilities\r\n        quality_price = [\r\n            [1.0, q.normal],\r\n            [SILVER_MULTIPLIER, q.silver],\r\n            [GOLD_MULTIPLIER, q.gold],\r\n            [IRIDIUM_MULTIPLIER, q.iridium],\r\n        ]\r\n            // prices are rounded down!\r\n            .map(([multiplier, p]) => Math.trunc(multiplier * base_price) * p)\r\n            .reduce((a, b) => a + b);\r\n    } else {\r\n        quality_price = base_price;\r\n    }\r\n\r\n    // We can sometimes get multiple crops per harvest, but all the extra crops\r\n    // will be regular quality.\r\n    // TODO: is this true? i see conflicting sources online\r\n    const num_crops_per_harvest = (crop.yield ?? 1) + (crop.percent_chance_extra ?? 0) / 100.0;\r\n    let revenue_per_harvest = quality_price + (num_crops_per_harvest - 1) * base_price;\r\n\r\n    if (settings.tiller_enabled) {\r\n        revenue_per_harvest *= 1.1; // could maybe do this before to get integer prices\r\n    }\r\n\r\n    // Okay, let's calculate everything!\r\n    const profit = revenue_per_harvest * num_harvests - crop.seed_cost;\r\n    const daily_profit = profit / useful_days;\r\n\r\n    return {\r\n        definition: crop,\r\n        useful_days,\r\n        num_harvests,\r\n        num_crops: num_crops_per_harvest * num_harvests,\r\n        profit,\r\n        daily_profit,\r\n    };\r\n}\r\n\r\n/* ======== GUI ======== */\r\n\r\n// Defines the set of columns for the whole table.\r\ntype Column = {\r\n    name: string;\r\n    cellText: (crop: CropData) => string;\r\n    compare: (a: CropData, b: CropData) => number;\r\n};\r\n\r\nconst COLUMNS: Column[] = [\r\n    {\r\n        name: \"Name\",\r\n        cellText: (crop: CropData) => crop.definition.name,\r\n        compare: (a: CropData, b: CropData) => a.definition.name.localeCompare(b.definition.name),\r\n    },\r\n    {\r\n        name: \"Seed Cost\",\r\n        cellText: (crop: CropData) => crop.definition.seed_cost.toString(),\r\n        compare: (a: CropData, b: CropData) => a.definition.seed_cost - b.definition.seed_cost,\r\n    },\r\n    {\r\n        name: \"Sell Price\",\r\n        cellText: (crop: CropData) => crop.definition.sell_price.toString(),\r\n        compare: (a: CropData, b: CropData) => a.definition.sell_price - b.definition.sell_price,\r\n    },\r\n    {\r\n        name: \"Days to Grow\",\r\n        cellText: (crop: CropData) => crop.definition.days_to_grow.toString(),\r\n        compare: (a: CropData, b: CropData) => a.definition.days_to_grow - b.definition.days_to_grow,\r\n    },\r\n    {\r\n        name: \"Regrowth Period\",\r\n        cellText: (crop: CropData) => crop.definition.regrowth_period?.toString() ?? \"-\",\r\n        compare: (a: CropData, b: CropData) => {\r\n            if (b.definition.regrowth_period === undefined) {\r\n                return -1;\r\n            } else if (a.definition.regrowth_period === undefined) {\r\n                return 1;\r\n            }\r\n            return a.definition.regrowth_period - b.definition.regrowth_period;\r\n        }\r\n    },\r\n    {\r\n        name: \"Yield\",\r\n        cellText: (crop: CropData) => {\r\n            const yield_num = crop.definition.yield ?? 1;\r\n            if (crop.definition.percent_chance_extra) {\r\n                return `${yield_num} + ${crop.definition.percent_chance_extra}%`;\r\n            } else {\r\n                return yield_num.toString();\r\n            }\r\n        },\r\n        compare: (a: CropData, b: CropData) => {\r\n            // slight hack -- represent as a + b/100\r\n            const a_num = (a.definition.yield ?? 1) + (a.definition.percent_chance_extra ?? 0) / 100;\r\n            const b_num = (b.definition.yield ?? 1) + (b.definition.percent_chance_extra ?? 0) / 100;\r\n            return a_num - b_num;\r\n        }\r\n    },\r\n    {\r\n        name: \"Useful Days\",\r\n        cellText: (crop: CropData) => crop.useful_days.toString(),\r\n        compare: (a: CropData, b: CropData) => a.useful_days - b.useful_days,\r\n    },\r\n    {\r\n        name: \"Num Harvests\",\r\n        cellText: (crop: CropData) => crop.num_harvests.toString(),\r\n        compare: (a: CropData, b: CropData) => a.num_crops - b.num_crops,\r\n    },\r\n    {\r\n        name: \"Num Crops\",\r\n        cellText: (crop: CropData) => {\r\n            const num_crops = crop.num_crops;\r\n            if (Number.isInteger(num_crops)) {\r\n                return num_crops.toString();\r\n            }\r\n            return crop.num_crops.toFixed(2);\r\n        },\r\n        compare: (a: CropData, b: CropData) => a.num_crops - b.num_crops,\r\n    },\r\n    {\r\n        name: \"Profit\",\r\n        cellText: (crop: CropData) => crop.profit.toFixed(2),\r\n        compare: (a: CropData, b: CropData) => a.profit - b.profit,\r\n    },\r\n    {\r\n        name: \"Daily Profit\",\r\n        cellText: (crop: CropData) => {\r\n            if (Number.isFinite(crop.daily_profit)) {\r\n                return crop.daily_profit.toFixed(2);\r\n            }\r\n            return \"-\";\r\n        },\r\n        compare: (a: CropData, b: CropData) => a.daily_profit - b.daily_profit,\r\n    }\r\n];\r\n\r\nclass CropRow {\r\n    data: CropData;\r\n    row: HTMLTableRowElement;\r\n\r\n    constructor(row: HTMLTableRowElement, data: CropData) {\r\n        this.data = data;\r\n        this.row = row;\r\n\r\n        // now populate the row\r\n        for (const col of COLUMNS) {\r\n            const value = col.cellText(this.data);\r\n            this.row.insertCell().appendChild(document.createTextNode(value));\r\n        }\r\n    }\r\n}\r\n\r\ntype SortDirection = \"ascending\" | \"descending\";\r\nfunction flipDirection(x: SortDirection): SortDirection {\r\n    switch (x) {\r\n        case \"ascending\":\r\n            return \"descending\";\r\n        case \"descending\":\r\n            return \"ascending\";\r\n    }\r\n}\r\n\r\nclass CropTable {\r\n    table: HTMLTableElement;\r\n    thead: HTMLTableSectionElement;\r\n    tbody: HTMLTableSectionElement;\r\n    rows: CropRow[];\r\n    current_sort: [number, SortDirection] | null;\r\n\r\n    constructor(table: HTMLTableElement) {\r\n        this.table = table;\r\n        this.rows = [];\r\n        this.current_sort = null;\r\n\r\n        // Create table header and body\r\n        this.thead = this.table.createTHead();\r\n        this.tbody = this.table.createTBody();\r\n\r\n        // Populate head once, here\r\n        const row = this.thead.insertRow();\r\n        for (const [idx, col] of COLUMNS.entries()) {\r\n            const cell = row.insertCell();\r\n            cell.appendChild(document.createTextNode(col.name));\r\n            cell.addEventListener(\"click\", () => {\r\n                // Which way do we sort?\r\n                let dir: SortDirection;\r\n                if (this.current_sort !== null && this.current_sort[0] === idx) {\r\n                    dir = flipDirection(this.current_sort[1]);\r\n                } else {\r\n                    dir = \"ascending\";\r\n                }\r\n                this.current_sort = [idx, dir];\r\n\r\n                // Clear all the header buttons, except ourselves\r\n                const headers = this.thead.querySelectorAll('td');\r\n                for (const header of headers) {\r\n                    header.removeAttribute(\"aria-sort\");\r\n                }\r\n                headers[idx].setAttribute(\"aria-sort\", dir);\r\n\r\n                // Now sort the rows\r\n                this.sortRows();\r\n            });\r\n        }\r\n\r\n        // We'll leave the body empty because it'll be recomputed from\r\n        // repopulateTable(), and we need the settings to be able to\r\n        // create the rows anyways.\r\n    }\r\n\r\n    // TODO: don't recreate rows; change the text instead\r\n    public repopulateTable(settings: Settings) {\r\n        // Discard the old rows and create new ones\r\n        this.tbody.replaceChildren();\r\n        this.rows = [];\r\n        for (const def of CROP_DEFINITIONS) {\r\n            // Filter to crops that are in-season\r\n            const data = calculate(def, settings);\r\n            if (data == \"out-of-season\") {\r\n                continue;\r\n            }\r\n            const row = this.tbody.insertRow();\r\n            this.rows.push(new CropRow(row, data));\r\n        }\r\n\r\n        // We also need to re-sort them. \r\n        this.sortRows();\r\n    }\r\n\r\n    private sortRows() {\r\n        // If no sort selected, default is to sort by name\r\n        let idx: number;\r\n        let dir: SortDirection;\r\n        if (this.current_sort === null) {\r\n            idx = 0;\r\n            dir = \"ascending\";\r\n        } else {\r\n            [idx, dir] = this.current_sort;\r\n        }\r\n\r\n        // We first sort our own collection, then use that to re-insert\r\n        // our row elements.\r\n        const col = COLUMNS[idx];\r\n        this.rows.sort((a, b) => {\r\n            const compare = col.compare(a.data, b.data);\r\n            return dir === \"ascending\" ? compare : -compare;\r\n        });\r\n\r\n        // Then use that to rearrange the nodes in the body\r\n        for (const row of this.rows) {\r\n            this.tbody.appendChild(row.row);\r\n        }\r\n    }\r\n}\r\n\r\ntype Inputs = {\r\n    season: Season,\r\n    start_day: number,\r\n    multiseason_checked: boolean,\r\n    quality_checked: boolean,\r\n    farming_level: number,\r\n    tiller_checked: boolean,\r\n};\r\n\r\nfunction visuallyEnableRow(row: HTMLElement, enable: boolean) {\r\n    for (let cell of row.querySelectorAll(\"td\")) {\r\n        if (enable) {\r\n            cell.classList.remove(\"disabled\");\r\n        } else {\r\n            cell.classList.add(\"disabled\");\r\n        }\r\n    }\r\n}\r\n\r\nfunction initialize() {\r\n    console.log(\"Initializing!\");\r\n\r\n    // Find all the elements I need\r\n    const table = document.getElementById(\"crop-table\");\r\n    if (!(table instanceof HTMLTableElement)) {\r\n        throw new Error(\"crop-table should be a <table>\");\r\n    }\r\n\r\n    const input_panel = document.getElementById(\"input-panel\")!;\r\n    const season_input = document.querySelector<HTMLInputElement>(\"#season\")!;\r\n    const current_day_input = document.querySelector<HTMLInputElement>(\"#day\")!;\r\n    const enable_multiseason = document.querySelector<HTMLInputElement>(\"#enable-multiseason\")!;\r\n    const enable_quality = document.querySelector<HTMLInputElement>(\"#enable-quality\")!;\r\n    const farming_level_input = document.querySelector<HTMLInputElement>(\"#farmer-level\")!;\r\n    const enable_tiller = document.querySelector<HTMLInputElement>(\"#enable-tiller\")!;\r\n\r\n    let quality_cells = {\r\n        normal: document.getElementById(`percent-normal`)!,\r\n        silver: document.getElementById(`percent-silver`)!,\r\n        gold: document.getElementById(`percent-gold`)!,\r\n        iridium: document.getElementById(`percent-iridium`)!,\r\n    };\r\n    let avg_quality_cell = document.getElementById(\"average-quality\")!;\r\n\r\n    // Create table component\r\n    const table_component = new CropTable(table);\r\n\r\n    // Read inputs\r\n    function readInputs(): Inputs {\r\n        return {\r\n            season: Season.fromString(season_input.value),\r\n            start_day: current_day_input.valueAsNumber,\r\n            multiseason_checked: enable_multiseason.checked,\r\n            quality_checked: enable_quality.checked,\r\n            farming_level: farming_level_input.valueAsNumber,\r\n            tiller_checked: enable_tiller.checked,\r\n        };\r\n    }\r\n\r\n    // Applies the input settings to the document\r\n    function readAndApplySettings() {\r\n        // Read all the inputs\r\n        const inputs = readInputs();\r\n\r\n        // Construct the settings\r\n        const quality = computeQuality(inputs.farming_level);\r\n        let settings: Settings = {\r\n            season: inputs.season,\r\n            start_day: inputs.start_day,\r\n            multiseason_enabled: inputs.multiseason_checked,\r\n            quality_probabilities: enable_quality.checked ? quality : null,\r\n            tiller_enabled: enable_tiller.checked,\r\n        };\r\n\r\n        // Touch the display elements\r\n        let q: QualityTypes;\r\n        for (q in quality_cells) {\r\n            const percent = 100 * quality[q];\r\n            quality_cells[q].textContent = `${percent.toFixed(0)}%`;\r\n        }\r\n        const quality_factor = quality.normal + quality.silver * 1.25 + quality.gold * 1.5 + quality.iridium * 2.0;\r\n        avg_quality_cell.textContent = quality_factor.toFixed(2);\r\n\r\n        // Disable certain elements\r\n        visuallyEnableRow(enable_tiller.parentElement!.parentElement!, inputs.farming_level >= 5);\r\n        if (inputs.farming_level < 5) {\r\n            settings.tiller_enabled = false;\r\n        }\r\n\r\n        for (q in quality_cells) {\r\n            visuallyEnableRow(quality_cells[q].parentElement!, inputs.quality_checked);\r\n        }\r\n        visuallyEnableRow(avg_quality_cell.parentElement!, inputs.quality_checked);\r\n\r\n        // Repopulate table and change style\r\n        table_component.repopulateTable(settings);\r\n        document.documentElement.className = season_input.value.toLowerCase();\r\n    }\r\n\r\n    // Run it once to apply the default settings.\r\n    readAndApplySettings();\r\n\r\n    // Attach event listeners\r\n    input_panel.addEventListener(\"change\", (event) => {\r\n        readAndApplySettings();\r\n    });\r\n}\r\n\r\n\r\n// Alrighty, we're ready to go! Wait for the DOM to finish loading (or see if it\r\n// already has.\r\nif (document.readyState === \"loading\") {\r\n    // Loading hasn't finished yet\r\n    document.addEventListener(\"DOMContentLoaded\", initialize);\r\n} else {\r\n    // `DOMContentLoaded` has already fired\r\n    initialize();\r\n}\r\n\r\nimport { foo } from './test';\r\n// foo();","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(505);\n"],"names":["Season","fromString","s","toUpperCase","SPRING","SUMMER","FALL","WINTER","Error","SILVER_MULTIPLIER","GOLD_MULTIPLIER","IRIDIUM_MULTIPLIER","calculate","crop","settings","seasons","num_seasons","multiseason","i","push","season","valueOf","includes","days_left","multiseason_enabled","length","indexOf","start_day","num_harvests","useful_days","days_to_grow","regrowth_period","extra_harvests","Math","floor","base_price","sell_price","quality_price","quality_probabilities","q","normal","silver","gold","iridium","map","multiplier","p","trunc","reduce","a","b","num_crops_per_harvest","yield","percent_chance_extra","revenue_per_harvest","tiller_enabled","profit","seed_cost","definition","num_crops","daily_profit","COLUMNS","name","cellText","compare","localeCompare","toString","undefined","yield_num","Number","isInteger","toFixed","isFinite","CropRow","constructor","row","data","this","col","value","insertCell","appendChild","document","createTextNode","flipDirection","x","CropTable","table","rows","current_sort","thead","createTHead","tbody","createTBody","insertRow","idx","entries","cell","addEventListener","dir","headers","querySelectorAll","header","removeAttribute","setAttribute","sortRows","repopulateTable","replaceChildren","def","sort","visuallyEnableRow","enable","classList","remove","add","initialize","console","log","getElementById","HTMLTableElement","input_panel","season_input","querySelector","current_day_input","enable_multiseason","enable_quality","farming_level_input","enable_tiller","quality_cells","avg_quality_cell","table_component","readAndApplySettings","inputs","valueAsNumber","multiseason_checked","checked","quality_checked","farming_level","tiller_checked","quality","p_gold_coin","p_iridium_coin","min","computeQuality","percent","textContent","quality_factor","parentElement","documentElement","className","toLowerCase","event","readyState","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}